#!/usr/bin/perl -w

use FindBin qw($Bin);   # Where is this script stored?  Put full path into $Bin
use lib ("$Bin/math","$Bin/modules","$Bin/../bin",$Bin);
use open ':std', ':encoding(UTF-8)';

use LoadPrimes;		# Load default constants...
use Getopt::Std;	# Allow for command line options
use constants;

# Key constants
$max_errors = 20;	# How many parser errors before we stop? (Not 0)
$eps = $defaults::eps;	# Error bound

getopts('adhlPsw:');

$opt_s or print "
reparse scans the prime database looking for any entries with the Reparse
flag set.  It then attempts to parse these with the full digit parser to
set 'log10', and 'digits'.  Sets the 'DigitRank' flag on entries that
are updated.  (\$eps is currently $eps)  Suggestion: run 'reparse -l',
then 'reparse' so the fast log parser handles the easy cases.\n\n";

$opt_h and print "reparse command line options

	-h	print this help info and exit reparse
	-a	act on all entries (not just those with thr 'ReParse' flag set)
        -w e    which primes to process (e.g., \"rank < 99\" or \"status LIKE '%Reparse%'\")
	-d	noisey debug options
	-l	use the log parser instead (will set Reparse flag on primes too close)
	-s	silent except for known errors (those greater than \$eps, includes -s)
	-P	do not mute error messages produced by the parser
";
$opt_h and exit;


unless ($opt_s) {
  $opt_P and print "Will NOT mute the errors generated by the parser.\n";
  $opt_a and print "Will scan all primes (Reparse flag set ot not).\n";
  $opt_l and print "Will use the log parser; so will (re)set Reparse flag on those too close to tell.\n";
  $opt_d and print "Noisey debug mode is on.\n";
  $opt_w and print "Process those primes \"WHERE $opt_w\".\n";
}

# Load the correct parser (b for pari exact, l for complex-log approximations)
my $parser = ($opt_l ? 'c' : 'b');
eval "require ${parser}math";  die $@ if $@;
eval "import  ${parser}math";
use parser;

# Tell the parser to not complain ?
$opt_P or $parser::GlobalShowParserErrors = 0;

# Prepare to count changes...
my $number_primes = 0; 		# Should be $count when done
my $number_unchanged = 0;	# How many examined and found close enough
my $number_updated = 0;		# How many changed in database (includes next)
my $number_toReparse = 0;	# How many flagged to reparse

# Need a database handle to modify primes
use connect_db;
my $dbh = &connect_db::connect();

# Do the work

my $which = "status LIKE '%Reparse%'" unless ($opt_a or $opt_w);
$which = $opt_w if $opt_w;
$count = &LoadPrimes::ProcessPrimes(\&Process,{'where'=>$which});

# pronounce victory and quit.
$opt_s or print "$count primes scanned, $number_updated updated".
	" ($number_unchanged unchanged, $number_toReparse of these marked to Reparse).\n";
exit;


#####  Got the prime as a hash reference, do something with it

sub Process {
  local $Prime = shift ||
    die 'Hey--where is the prime hash????';
  ++$number_primes;

  ### Reparse the prime

  my ($Log10, $digits);
  $opt_d and warn "parse($$Prime{'description'},'log only')\n";

  if ($$Prime{'quoted'}) {
    if ($p = &LoadPrimes::LoadBlob($$Prime{'description'},$$Prime{'blob_id'})) {
      $opt_d and print "$$Prime{'description'} quoted--using blob to get size.\n";
      $Log10 = $$p{'log_10'};
      $digits = $$p{'digits'};
    } else {
      $Log10 = 'NaN';
      warn("Hey! add $$Prime{'id'}: $$Prime{'description'} to 'prime_blob'!\n");
    }
  } elsif ($opt_l) {
    $Log10 = &parser::parse($$Prime{'description'},'log only')/log(10);
  } else {
    # Need an eval block here for the pari parser until it is more stable!
    eval "\$Log10 = &parser::parse(\$\$Prime{'description'},'log only')";
    if ($@) {  # Oh-oh!  eval error
      print "reparse: Parse error on $$Prime{'description'}:\n\t$@\n";
      $Log10 = 'NaN';
    }
    $Log10 = $Log10/log(10); # parser returns natural log
  }

  $opt_d and warn "\t Parser returns log10 = $Log10 (digits = ".($digits||'undef').")\n";

  ## Check if we can clearly tell the number of digits

  unless (not(ref($Log10)) and $Log10 eq 'NaN') {
    if ($$Prime{'quoted'}) {
      # $digits is set by the blob
    } elsif (int($Log10*(1.0+$eps)) == int($Log10/(1.0+$eps)) or $Log10 > 100000000) {
      # Possible to tell number of digits
      $digits = int($Log10+1);
    } else {
      # Too close, look harder if full digit parser
      $opt_d and print "\tToo close to tell; using full digit parser.\n";
      $digits = ($opt_l ? 'NaN' : &parser::parse($$Prime{'description'},'digits'));
    }
  }
  $opt_d and warn "\tdigits is $digits.\n";

  ### Now lets act on what we know--update if necessary...

  if (not(ref($Log10)) and $Log10 eq 'NaN') {
    $number_updated++;
    $number_toReparse++;

    # Make sure flagged to ReParse again! (e.g., if called with -a)
    $query = "UPDATE prime SET status = CONCAT(status,',Reparse') WHERE id = '$$Prime{id}'";
    $opt_d and warn "$query\n";
    $opt_s or warn "($number_primes:$number_updated) In $$Prime{'id'}: $$Prime{'description'}
	Too close for the log paser to determine the exact number of digits.  Set Reparse flag.\n";
    $sth = $dbh->prepare($query) || die $sth->errstr;
    $sth->execute() || die $sth->errstr;

    # Parser failed--a true error that must be reported
    if ($$Prime{'quoted'}) {
      warn "Parser failed (but prime was quoted):\n\t".
	&LoadPrimes::ShowText($Prime);
      die "Maximum errors reached!\n"  unless --$max_errors;
    } else {
      warn "Parser failed on this prime:\n\t".
	&LoadPrimes::ShowText($Prime);
      die "Maximum errors reached!\n"  unless --$max_errors;
    }

  } elsif (not(ref($digits)) and $digits eq 'NaN') {
    # Should only be possible with the log parser--too close to tell
    # (or the parser would never have been called in 'digits' mode)
    $number_updated++;
    $number_toReparse++;
    $opt_l or die "$0 Failed to calculate the number of digits in $$Prime{'id'}: $$Prime{'description'}
	--should only happed with -l. Should the prime description be quoted?\n";
    $query = "UPDATE prime SET status = CONCAT(status,',Reparse') WHERE id = '$$Prime{id}'";
    $opt_d and warn "$query\n";
    $opt_s or warn "($number_primes:$number_updated) In $$Prime{'id'}: $$Prime{'description'}
	Too close for the log paser to determine the exact number of digits.  Set Reparse flag.\n";
    $sth = $dbh->prepare($query) || die $sth->errstr;
    $sth->execute() || die $sth->errstr;

  } elsif ($digits == $$Prime{'digits'} and abs($Log10 - $$Prime{'log_10'}) < $eps) {
    # Everything is fine!  The two parser have different accuracies...
    $number_unchanged++;
    $query = "UPDATE prime SET status = REGEXP_REPLACE(status,'Reparse,?','') WHERE id = '$$Prime{id}'";
    $opt_d and warn "$query\n";
    $opt_s or warn "($number_primes:$number_updated) In $$Prime{'id'}: $$Prime{'description'}
	Digits check out--turning off Reparse flag.\n";
    $sth = $dbh->prepare($query) || die $sth->errstr;
    $sth->execute() || die $sth->errstr;

  } else {  # Update this prime
    $number_updated++;
    ## print "\n>>> status='".$$Prime{'status'}."'\n";
    my $set = "status = IF(status+0 > 0, CONCAT(REGEXP_REPLACE(status,'Reparse,?',''),',DigitRank'),'DigitRank')";
    $set .= ", log10 = $Log10"   if  $Log10  != $$Prime{'log_10'};
    $set .= ", digits = $digits" if  $digits != $$Prime{'digits'};
    $query = "UPDATE prime
          SET $set
          WHERE id = '$$Prime{id}'";
    $opt_d and warn "$query\n";
    $opt_s or warn "($number_primes:$number_updated) In $$Prime{'id'}: $$Prime{'description'}
	changing $$Prime{'log_10'} to $Log10 and $$Prime{'digits'} to $digits.\n";
    $sth = $dbh->prepare($query);
    $sth->execute();
  }

  # Return 1, or the processing of primes will stop dead!
  1;
}

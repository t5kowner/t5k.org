package linear;

# This module contains the functions for evaluating terms in linear sequences
# It depends heavily on the module math.
#
#   These can be called with on variable (n) or three (p,q,n):
#
#       U, primU                Fibonacci numbers (& primitive parts)
#       V, primV                Lucas numbers (& primitive parts)

#	A(n), primA(n)		Aruifuilean factorizations all defined
#	B(n), primB(n)		only if n is 5 modulo 10.
# 
#	Linear(f0,f1,f2,f3,n)	The nth term of the linear sequence starting fo,f1,f2,f3...
#	S(n), W(n)		Linear(1,1,3,7,n) and Linear(0,1,2,5,n) respectively


sub U {
  # Either U(n) = U(1,-1,n) (the usual Fibonacci numbers) or the Lucas sequence
  # U(p,q,n) generated by p and q.  (Was called lucasU(p,q,n).)

  my ($n, $x, $y, $p, $q, $z);  # Either way, U(n) = (x^n - y^n)/(x-y) (so fails if disc = 0)
  if (ref($_[0]) eq 'ARRAY') {  # Three variable case
    $p = $_[0][0];
    $q = $_[0][1];
    return 'NaN' unless &math::is_real($n = $_[0][2]);
    # Now get the discrimant of the form
    my $disc = &math::sqrt_(&math::sub(&math::mul($p,$p), &math::mul(&math::new(4),$q)));
#    if (&math::is_zero($disc)) {
#      warn "Zero discriminant (p^2-4q) makes U(p,q,n) and V(p,q,n) undefined.\n";
#      return 'NaN';
#    }
    # Find the two roots
    $x = &math::div(&math::add($p,$disc), &math::new(2));
    $y = &math::div(&math::sub($p,$disc), &math::new(2));  
  } else {
    return 'NaN' unless &math::is_real($n = shift());
    $x = &math::new( 1.618033988749894848205,0);
    $y = &math::new(-0.618033988749894848205,0);
  }
  if (&math::is_zero(&math::sub($x,$y))) { 
    # discriminant so relatively small behaves like zero, use n*x^(n-1)
    warn "Using x-y=0 form in U: ".&math::show($n).&math::show($x,'both').",".&math::show($y,'both')."\n";
    $z = &math::mul( $n, &math::pow($x, &math::sub($n,&math::new(1)) ) );
  } else {
    $z = &math::div(&math::sub(&math::pow($x,$n),&math::pow($y,$n)), &math::sub($x,$y));
  }

  # Force the answer to be real? ($p, $q are undefined in the and variable case)
  if (!defined($p) or &math::is_real($p) and &math::is_real($q)) {
    # Remove the roundoff errors in the angle by forcing it to be 0
    {'ln_r'=>$$z{'ln_r'},'theta'=>0};
  } else {
    $z;
  }
# warn "zzz1 n,z: ".&math::show($n).&math::show($z,'both')."\n";
}


sub V {
# For the Lucas numbers we use U(n)*V(n) = U(2n)
  if (ref($_[0]) eq 'ARRAY') {  # Three variable case
    # &V(p,q,n) is U(p,q,2n)/U(p,q,n)
    my $p = $_[0][0]; 
    my $q = $_[0][1];
    my $n = $_[0][2];
    &math::div(&U([$p,$q,&math::mul($n, &math::new(2,0))]), &U([$p,$q,$n]));
  } else {
    return 'NaN' unless &math::is_real(my $n = shift);
    &math::div(&U(&math::mul($n, &math::new(2,0))), &U($n));
  }
}

sub primU {
# Evaluates the primitive part of the n-th (n = exp(ln_n)) Fibonacci
# number and returns its natural log (assumes n > 1).  See:
#
#   "Table of Fibonacci and Lucas Factorizations" by Brillhart,
#    Montgomery and Silverman, Math. Comp. v50, 181, p251-260 
#    Jan 1988.
#
# Note that the primitive part of the n-th Lucas number is the
# primitive part of the 2n-th Fibonacci number (same article).        }
# We assume n is an integer (which we force with int).

  my ($n, $x, $y);
  if (ref($_[0]) eq 'ARRAY') {  # Three variable case
    my $p = $_[0][0];
    my $q = $_[0][1];
    $n = $_[0][2];
    # Now get the discrimant of the form
    my $disc = &math::sqrt_(&math::sub(&math::mul($p,$p), &math::mul(&math::new(4),$q)));
    if (&math::is_zero($disc)) {
      warn "zero discriminant in primU so aborting.\n";
      return 'NaN';
    }
    # Find the two roots
    $x = &math::div(&math::add($p,$disc), &math::new(2));
    $y = &math::div(&math::sub($p,$disc), &math::new(2));
  } else {
    $n = shift;
    $x = &math::new(1.618033988749894848205,0);
    $y = &math::new(-0.618033988749894848205,0);
  }

  $n = &math::cyclotomic($n,$x,$y);
  # Remove the roundoff errors in the angle by forcing it to be 0
  {'ln_r'=>$$n{'ln_r'},'theta'=>0}
}
     
sub primV {
# For the Lucas numbers we use primV(n) = primU(2n)
  if (ref($_[0]) eq 'ARRAY') {
    my $p = $_[0][0];
    my $q = $_[0][1];
    my $n = $_[0][2];
    &primU([$p,$q,&math::mul($n, &math::new(2,0))]);
  } else {
    &primU(&math::mul(shift(), &math::new(2,0)));
  }
}
  
sub Linear {
  # If a two-term linear recurrence exists with those first four initial
  # values, pfgw could solve for the recurrence coefficients, solve the
  # quadratics, and then calculate Linear(), so
  #
  #   Linear(0,1,1,2,n) is U(n)
  #   Linear(2,1,3,4,n) is V(n)
  #   Linear(1,7,41,239,n) is the NSW numbers
  #
  # Roughly we have Linear(f0, f1, f2, f3, n) = fn

  # Get the variables first
  my $f0 = $_[0][0];
  my $f1 = $_[0][1];
  my $f2 = $_[0][2];
  my $f3 = $_[0][3];
  my $n  = $_[0][4];  &math::is_real($n) or return 'NaN';

  # Solve for c1, c2 where f(n+1) = c1*f(n) + c2*f(n-1)
  my $d = &math::sub(&math::mul($f1,$f1), &math::mul($f2,$f0));
  if (&math::is_zero($d)) {
    warn "Can not solve for coefficients in linear recurrence";
    return 'NaN';
  }
  my $c1 = &math::div( &math::sub(&math::mul($f2,$f1), &math::mul($f3,$f0)), $d);
  my $c2 = &math::div( &math::sub(&math::mul($f1,$f3), &math::mul($f2,$f2)), $d);
  
  # Now solve the quadratic x^2 = c1*x + c2.  First let $d be the discriminant
  $d = &math::add(&math::mul($c1,$c1), &math::mul(&math::new(4),$c2));
  $d = &math::sqrt_($d);
  # Find the two roots
  my $r1 = &math::div(&math::add($c1,$d),&math::new(2));
  my $r2 = &math::div(&math::sub($c1,$d),&math::new(2));

  # Place the answer in $z.  Two cases: distinct roots, double root:
  my $z = 'NaN';
  if (!&math::is_zero($d)) {
    # The result is : $a1*$r1^$n + $a2*$r2^$n 
    # solve for $a1 and a2 from the initial conditions
    my $a1 = &math::div(&math::sub($f1,&math::mul($f0,$r2)),&math::sub($r1,$r2));
    my $a2 = &math::sub($f0,$a1);
    $z = &math::add(&math::mul($a1,&math::pow($r1,$n)),&math::mul($a2,&math::pow($r2,$n)));
  } else {
    # The result is : $a1*$r1^$n + $a2*$n*$r2^$n 
    # solve for $a1 and a2 from the initial conditions to find $a1 = $f0 and 
    my $a2 = &math::sub(&math::div($f1,$r1), $f0);
    $z = &math::mul( &math::add($f0,&math::mul($a2,$n)), math::pow($r2,$n));
  }

  # If the answer should be real, remove the roundoff errors in the angle by forcing it to be 0
  if (&math::is_real($f0) and &math::is_real($f1) and &math::is_real($f2) and &math::is_real($f3)) {
    {'ln_r'=>$$z{'ln_r'},'theta'=>0}
  } else {
    $z
  }
}

sub S {
  Linear([&math::new(1), &math::new(1), &math::new(3), &math::new(7), shift()]);
}
 
sub W {
  Linear([&math::new(0), &math::new(1), &math::new(2), &math::new(5), shift()]);
}

sub A {  # n == 5 (mod 10)
  # A($n), B($n) calculate the non-primitive form of A( ) and B( )
  # So here we MUST have $n == 5 (mod 10)
  &math::is_real(my $n = shift()) or return 'NaN';
  my $five = &math::new(5);
  my $U = &U(&math::div($n,$five));
  &math::inc( &math::mul( &math::sub($U,&math::new(1)), &math::mul($five,$U) ) )
}

sub B {  # n == 5 (mod 10)
  # A($n), B($n) calculate the non-primitive form of A( ) and B( )
  # So here we MUST have $n == 5 (mod 10)
  &math::is_real(my $n = shift()) or return 'NaN';
  my $five = &math::new(5);
  $n = &math::div($n,$five);
  my $U = &U($n);
  &math::inc(&math::mul(&math::inc($U),&math::mul($five,$U)))
}


sub primA {
# Evaluates the primitive part of the Lucas Aurifeullian factorization. The
# argument MUST be 5 modulo 10 for these to be defined! See equation 2.10 in
#
#       Tables of Fibonacci and Lucas Factorizations
#       J. Brillhart, P. Montgomery, R. Silverman
#       Math. Comp 50:181, January 1988, 251-260.
#
# Note that his e_d = 1 (d == 1 or 4 mod 5) and e_d = 0 otherwise.

  defined (my $n = shift()) or return 'NaN';
    
  if (int(&math::__real($n)+0.5) % 10 != 5) {  # Not defined in this case!
    warn("A, B, primA, primB are defined only if n = 5 (mod 10).  n is ". 
	&math::__real($n)."\n");
    return 'NaN';
  }
    
  # Form a hash table of divisors d (keys) paired with (what will eventually
  # be) the Mobius value of d (values). Since the latter will be a multiplier
  # in a sum we can skip the ones for which this value will be zero--e.g.,
  # those divisible by a prime square
    
  my %divisors;
  $divisors{1} = 1;
  my $factors = &primes::Factor(int(&math::__real($n)+0.5));
    
  foreach my $p (keys %{$factors}) {
    foreach my $d (keys %divisors) {
      $divisors{$d*$p} = - $divisors{$d}
    }
  }
  
  # Now process the list
    
  my $result = &math::new(1);
  foreach my $d (keys %divisors) {
    my $u = delete $divisors{$d};
    next if $d % 5 == 0;
    my $D = &math::new($d);
    if ($d % 5 == 1 or $d % 5 == 4) {
      $result = &math::mul($result,&math::pow(&A(&math::div($n,$D)),&math::new($u)));
    } else {
      $result = &math::mul($result,&math::pow(&B(&math::div($n,$D)),&math::new($u)));
    }
  } 
  $result;
}
  
sub primB {
 my $n = shift;
 &math::div(&primV($n),&primA($n));
}


1;
